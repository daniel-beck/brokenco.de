--- 
layout: post
title: Experimenting with Git at Slide (Part 1/3)
tags: 
- slide
- opinion
- software development
- git
created: 1217161428
---
For the past two months I've been experimenting with varying levels of success with <a href="http://git.or.cz/" target="_blank">Git</a> inside of <a href="http://www.slide.com" target="_blank">Slide, Inc.</a>. Currently Slide makes use of <a href="http://subversion.tigris.org/" target="_blank">Subversion</a> and relies heavily on branches in Subversion for everything from project specific branches to release branches (branches that can live anywhere from under 12 hours to three weeks). There are plenty of other blog posts about the pitfalls of branching in Subversion that I won't go into here, suffice to say, it is...sub-par. Below is a rough diagram of our general current workflow with Subversion (I've had some other developers ask me "why don't you just work in trunk?" to which I usually wax poetic about the chaos of trunk when any project gets over 5 active developers (Slide engineering is somewhere between 30-50 engineers)).<br>
<center><a href="http://agentdero.cachefly.net/unethicalblogger.com/images/Subversion%20Workflow.png" rel="lightbox"><img src="http://agentdero.cachefly.net/unethicalblogger.com/images/Subversion%20Workflow.png" width="460"/></a></center><br>
<br>
<ul><li><a href="#catch">There's always a catch</a></li><li><a href="#svn">Subversion at Slide</a></li><li><a href="#toying">Toying with Git</a></li><li><a href="#git">Git at Slide</a></li></ul><a name="catch"/><br>
<h3>There's always a catch</h3>There are three major problems we've run up against with utilizing Subversion as our version control system at Slide:<ul><li>Subversion's "branches" make context switching difficult</li><li>Depending on the age of a branch cut from <span style="font-family: monospace;">trunk/</span>, merges and maintainence is between difficult and impossible</li><li>Merging Subversion branches into each other causes a near total loss of revision history</li></ul>Given that branches are a critical part of Slide's development process, we've historically looked at branch-strong version control systems as alternatives, such as <a href="http://perforce.com" target="_blank">Perforce</a>. Before I joined Slide in April of 2007, I was a heavy user of Perforce for my own consulting projects as well as for some of my work with the <a href="http://FreeBSD.org" target="_blank">FreeBSD project</a> as part of the Summer of Code program. In fact, my <a href="http://stuffonfire.com/" target="_blank">boss</a> sent out a "Perforce Petition" to our engineering list on my third day at Slide...we still haven't switched away from Perforce. <br>
<br>
<center><a href="http://agentdero.cachefly.net/unethicalblogger.com/images/git_tweet.png" rel="lightbox"><img src="http://agentdero.cachefly.net/unethicalblogger.com/images/git_tweet.png" width="500"/></a></center><br>
<br>
Up until earlier this year I hadn't given it a second thought until the team I was working with grew and grew such that between me and four other engineers we were pushing a release anywhere from once to three times a week. That meant we were creating a Subversion "branch" multiple times a week, and a significant part of my daily routine became merging to our release branch and refreshing project branches from <span style="font-family: monospace;">trunk/</span>. All of a sudden Git was looking prettier and prettier, despite some of its warts. At this point in time I was already using Git for some of my personal projects that I never have time for, so I knew at the bare minimum that it was functional. What I didn't know was how to deploy and use it with a large engineering team that works in very high churn short iterations, like Slide's.<br>
<a name="svn"/><br>
<h3>Subversion at Slide</h3>Moving our source tree over into a system other than Subversion, from Subverison, was destined to be painful. The tree at Slide is deceptively large, we have a substantial amount of <a href="http://www.python.org" target="_blank">Python</a> running around (as Slide is built, top-to-bottom, in Python) and an incredible amount of Adobe Flash assets (.swf files), Adobe Illustrator assets (.ai files) and plenty of binary files, like images (.png/gif/jpeg). Currently a full checkout of <span style="font-family: monospace;">trunk/</span> is roughly <strong>2.5GB</strong> including artwork, flash, server and web application code. We also have roughly <strong>88k</strong> revisions in Subversion, the summation of three years of the company's existence. Fortunately somebody along the line wrote a script (in Perl however) called "<a href="http://www.kernel.org/pub/software/scm/git/docs/git-svn.html" target="_blank">git-svn(1)</a>" that is designed to do exactly what I needed, move a giant tree from Subversion to Git, from start to finish (similar to <a href="http://public.perforce.com/wiki/SVN2P4" target="_blank">svn2p4</a> in Perforce parlance).<br>
<br>
<a name="toying"><br>
<h3>Toying with Git</h3>When I first ran the command `<span style="font-family: monospace;">git-svn init $SVN</span>` I let the the command run for somewhere close to 6-7 hours before completing, I was shocked at the size of the generated repository. If our Git repository were to be left unpacked <span style="font-family: monospace;">.git/</span> <strong>alone</strong> would be close to <strong>9GB</strong>, adding the actual code on top of it, ~11GB. I decided that maybe packing this repository would be a good idea so I ran `<span style="font-family: monospace;">git gc</span>` and went to grab a coke from the fridge ... and the machine ran out of memory. One of our quad-core, 8GB RAM, shared development machines ran out of memory?!<br>
<center><img src="http://agentdero.cachefly.net/unethicalblogger.com/images/do-not-want.jpg"/></center><br>
<br>
After lurking in #git on Freenode for a while I determined two things<ol><li>Apparently nobody uses Git for projects this large</li><li>Git was retaining too much memory, like a memory leak, but just don't call it a memory leak.</li></ol> To compound this, the rules for memory usage with Git are vastly different between a 32-bit machine and a 64-bit machine, and because we're just that cool, we're using 64-bit machines across the board. The amount of memory Git decides to keep resident while doing repository-intensive operations like the `<span style="font-family: monospace;">git gc</span>`, is 256MB on 32-bit machines, and 8GB on 64-bit machines. As these machines are shared between developers we use of <span style="font-family: monospace;">ulimit(1)</span>, when you limit memory usage with <span style="font-family: monospace;">ulimit(1)</span> it restricts <em>address space</em> meaning both virtual and resident memory. When Git tried to <span style="font-family: monospace;">mmap(2)</span> gigabytes of address space to do it's operations, the kernel stepped in to intervene and started returning <span style="font-family: monospace;">ENOMEM</span> to Git which promptly exited.<br>
<br>
After raising this enough times, I finally caught <a href="http://www.spearce.org/" target="_blank">spearce</a> who was able to identify the problem and supply a <a href="http://marc.info/?l=git&m=121558741815427&w=2" target="_blank">patch</a> that fixed the memory allocation issues with Git and a repository of Slide's size. First obstacle overcome, now I could actually test a Git workflow inside of Slide.<br>
<br>
<a name="git"><br>
<h3>Git at Slide</h3>Now that I could pack the repository on our development machines, I could get the repository down to a reasonable 3.0GB, i.e. <span style="font-family: monospace;">.git/</span> weighed in at 3GB making a entire tree ~5.5GB (far more managable than 11GB). Despite Git being a decentralized version control system, we still needed some semblance of centralization to ensure a couple basic rules for a sane workflow:<ul><li>A centralize place to synchronize distributed versions of the repository</li><li>Changesets cannot be lost, ever.</li><li>QA must not be over-burdened when testing releases</li></ul>This meant we needed a centralized, secure, repository which left us two options: Git over WebDav (https/http) <em>or</em> <a href="http://scie.nti.st/2007/11/14/hosting-git-repositories-the-easy-and-secure-way" target="_blank">Gitosis</a>. After discovering that `<span style="font-family: monospace;">git-http-push(1)</span>, the executable responsible for doing Git pushes over WebDav has tremendous memory issues, I abandoned that as an option (a `<span style="font-family: monospace;">git push</span>` of the repository resulted in memory usage peaking at 11GB virtual, 3.5GB resident memory).<br>
<br>
If you are looking to deploy Git for a larger audience in a corporate environment, I highly recommend Gitosis. What Gitosis does is allows for SSH to be used as the transport protocol for Git, and provides authentication by use of limited-shell user accounts and SSH keys; it's not perfect but it's the closest thing to maintainable for larger installations of Git (in my opinion). <br>
<br>
So far the experimenting with Git at Slide is pretty localized to just my team, but with a combination of Gitosis, git-svn(1) and some "best practices" defined for handling the new system we've successfully continued development for over the past month without any major issues. <br>
<br>
As this post is already quite lengthy, I'll be discussing the following two parts of our experimenting in subsequent posts:<ul><li><a href="http://unethicalblogger.com/posts/2008/09/team_development_with_git_part_23">Team Development with Git</a></li><li>Git back to Subversion, mostly automatically.</li></ul><br/><br>
<hr/><br>
<em>Did you know!</em> <a href="http://www.slide.com/static/jobs">Slide is hiring</a>! Looking for talented engineers to write some good Python and/or JavaScript, feel free to contact me at tyler[at]<a href="http://slide.com">slide</a><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
